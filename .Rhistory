# safe sequence function for one row
safe_seq <- function(from, to) {
# handle NA
if (is.na(from) || is.na(to)) return(as.POSIXct(NA_real_))
# ensure POSIXct
if (!inherits(from, "POSIXt")) from <- as.POSIXct(from)
if (!inherits(to,   "POSIXt")) to   <- as.POSIXct(to)
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
# normal case: one-minute sequence
seq(from, to, by = "1 min")
}
# Expand row-by-row safely. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])   # scalar access
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dtl[, rowid := NULL]
# optional: remove rows where date.time is NA (if you used NA for invalid rows)
dtl <- dtl[!is.na(date.time)]
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
# # make long format for mearging
# dcl <- melt(
#   dc,
#   id.vars = c('chamber', 'ID', 'start.N2O', 'end.N2O'),
#   measure.vars = c('begin.time', 'final.time'),
#   variable.name = 'time',
#   value.name = 'date.time'
# )
#
# # change dc begin time to same format as date.time in da
# dcl[, date.time := as.POSIXct(date.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# handle NA
if (is.na(from) || is.na(to)) return(as.POSIXct(NA_real_))
# ensure POSIXct
if (!inherits(from, "POSIXt")) from <- as.POSIXct(from)
if (!inherits(to,   "POSIXt")) to   <- as.POSIXct(to)
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
# normal case: one-minute sequence
seq(from, to, by = "1 min")
}
# Expand row-by-row safely. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])   # scalar access
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dtl[, rowid := NULL]
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# handle NA
if (is.na(from) || is.na(to)) return(as.POSIXct(NA_real_))
# ensure POSIXct
# if (!inherits(from, "POSIXt")) from <- as.POSIXct(from)
# if (!inherits(to,   "POSIXt")) to   <- as.POSIXct(to)
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
# normal case: one-minute sequence
seq(from, to, by = "1 min")
}
# Expand row-by-row safely. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])   # scalar access
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dtl[, rowid := NULL]
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# handle NA
#  if (is.na(from) || is.na(to)) return(as.POSIXct(NA_real_))
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
# normal case: one-minute sequence
seq(from, to, by = "1 min")
}
# Expand row-by-row safely. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])   # scalar access
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dtl[, rowid := NULL]
View(dtl)
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = "%d-%m-%Y %H:%M", tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# if to < from, return NA (or return reversed/empty based on preference)
#  if (to < from) return(as.POSIXct(NA_real_))
# normal case: one-minute sequence
seq(from, to, by = "1 min")
}
# Expand row-by-row safely. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])   # scalar access
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# Expand row-by-row. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
seq(from, to, by = '1 min')
}
# Expand row-by-row. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dtl <- dc[
, {
dtthis <- safe_seq(begin.time[1], final.time[1])
.(date.time = dtthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dtl[, rowid := NULL]
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
seq(from, to, by = '1 min')
}
# Expand row-by-row. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dcl <- dc[
, {
dcthis <- safe_seq(begin.time[1], final.time[1])
.(date.time = dcthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dcl[, rowid := NULL]
# challenge that we have some measurements that start and stop on the same times.stamp
# because the resolution is minutes, not seconds....
# the times we have dublicates:
dcl[duplicated(date.time), unique(date.time)]
# making a full mearge, mening that when we have the same date.time for start and stop
# it will be dublicated
dt <- merge(da, dcl, by = "date.time", all.x = TRUE, allow.cartesian = TRUE)
View(dt)
# dropping Aeris data when not measured on chamber:
dt <- [! is.na(dt$start.N2O), ]
# dropping Aeris data when not measured on chamber:
dt <- [! is.na(dt$start.N2O)]
# dropping Aeris data when not measured on chamber:
dt <- dt[!is.na(start.N2O)]
ggplot(dt, aes(start.N2O, end.N2O)) + geom_point()
library(ggplot)
library(gplot)
library(gplot1)
library(gplot2)
library(ggplot2)
ggplot(dt, aes(start.N2O, end.N2O)) + geom_point()
ggplot(dt, aes(start.N2O, end.N2O, color = chamber)) + geom_point()
ggplot(dt, aes(start.N2O, end.N2O, color = chamber)) +
geom_point() +
facet_wrap(~ chamber)
dt[dt$chamber == '11', ]
test <- dt[dt$chamber == '11', ]
View(test)
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
seq(from, to, by = '1 min')
}
# Expand row-by-row. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dcl <- dc[
, {
dcthis <- safe_seq(begin.time[1], final.time[1])
.(date.time = dcthis)
},
by = .(rowid, chamber, ID, start.N2O, end.N2O)
]
# drop helper rowid
dcl[, rowid := NULL]
# challenge that we have some measurements that start and stop on the same times.stamp
# because the resolution is minutes, not seconds....
# the times we have dublicates:
dcl[duplicated(date.time), unique(date.time)]
# making a full mearge, mening that when we have the same date.time for start and stop
# it will be dublicated
dt <- merge(da, dcl, by = "date.time", all.x = TRUE, allow.cartesian = TRUE)
# dropping Aeris data when not measured on chamber:
#dt <- dt[!is.na(start.N2O)]
# trying to make a plot
library(ggplot2)
ggplot(dt, aes(start.N2O, end.N2O, color = chamber)) +
geom_point() +
facet_wrap(~ chamber)
test <- dt[dt$chamber == '11', ]
View(da)
View(dc)
# clear workspace
rm(list = ls())
library(readxl)
library(dplyr)
library(lubridate)
library(writexl)
library(data.table)
# I removed this as this path only works on your (Lorenzos) computer.
# setwd("~/Desktop/Università/DiANA/Dottorato/Danimarca/AU/Aeris GHG Graes")
# loading data
da <- read_excel("Excel Aeris.xlsx")
dc <- fread("chamber_data_complete.csv")
# cleaning data
setnames(dc, as.character(dc[1, ]))
dc <- dc[-1, ]
dc$start.N2O <- as.numeric(dc$start.N2O)
dc$end.N2O <- as.numeric(dc$end.N2O)
# selecting dc data for N2O
dc <- dc[! is.na(start.N2O), c('chamber', 'ID', 'begin.time', 'final.time', 'start.N2O', 'end.N2O')]
da <- as.data.table(da)
# Lorenzo, I am unsure if the data there is in the dc is Aeries time or 'real time'?
# if it is Aeris time then the next line correting the time should not be done
# here, but you should correct time time after mearging and before including
# temperature data.
# correcting Aeris time
# N2O aeris is 1 hour behind real time
da[ , date.time := Datatime + 1 * 3600]
# making a date.time column for mearing, rounded to nearest minute
da[, date.time := as.POSIXct(round(Datatime, "mins"), tzone = 'UTC')]
# change dc begin time to same format as date.time in da
dc[, begin.time := as.POSIXct(begin.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
dc[, final.time := as.POSIXct(final.time, format = '%d-%m-%Y %H:%M', tzone = 'UTC')]
# adding rows with chamber, id and N2O info for between begin.time and final.time
# sequence function for one row
safe_seq <- function(from, to) {
# if to < from, return NA (or return reversed/empty based on preference)
if (to < from) return(as.POSIXct(NA_real_))
seq(from, to, by = '1 min')
}
# Expand row-by-row. Use rowid to ensure seq() gets scalars.
dc[, rowid := .I]
dcl <- dc[, {dcthis <- safe_seq(begin.time[1], final.time[1])
.(date.time = dcthis)},
by = .(rowid, chamber, ID, start.N2O, end.N2O)]
# drop helper rowid
dcl[, rowid := NULL]
# challenge that we have some measurements that start and stop on the same times.stamp
# because the resolution is minutes, not seconds....
# the times we have dublicates:
dcl[duplicated(date.time), unique(date.time)]
# making a full mearge, mening that when we have the same date.time for start and stop
# it will be dublicated
dt <- merge(da, dcl, by = "date.time", all.x = TRUE, allow.cartesian = TRUE)
# dropping Aeris data when not measured on chamber:
dt <- dt[!is.na(start.N2O)]
# # trying to make a plot just to see that is looks ok
#
# library(ggplot2)
# ggplot(dt, aes(start.N2O, end.N2O, color = chamber)) +
#   geom_point() +
#   facet_wrap(~ chamber)
# something is wrong, data is missing - e.g. chamber 11 there is only the first days of
# measurements and not the subsequent ones.
test <- dt[dt$chamber == '11', ]
